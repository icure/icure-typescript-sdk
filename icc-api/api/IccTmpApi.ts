/**
 * iCure Cloud API Documentation
 * Spring shop sample application
 *
 * OpenAPI spec version: v0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import { XHR } from './XHR'
import { Classification } from '../model/Classification'
import { Contact } from '../model/Contact'
import { DocIdentifier } from '../model/DocIdentifier'
import { Document } from '../model/Document'
import { Form } from '../model/Form'
import { HealthElement } from '../model/HealthElement'
import { Invoice } from '../model/Invoice'
import { Message } from '../model/Message'
import { PaginatedListClassification } from '../model/PaginatedListClassification'
import { PaginatedListDocument } from '../model/PaginatedListDocument'
import { PaginatedListForm } from '../model/PaginatedListForm'
import { PaginatedListHealthElement } from '../model/PaginatedListHealthElement'
import { PaginatedListInvoice } from '../model/PaginatedListInvoice'
import { PaginatedListPatient } from '../model/PaginatedListPatient'
import { Patient } from '../model/Patient'
import { Unit } from '../model/Unit'

export class IccTmpApi {
  host: string
  headers: Array<XHR.Header>
  fetchImpl?: (input: RequestInfo, init?: RequestInit) => Promise<Response>

  constructor(host: string, headers: any, fetchImpl?: (input: RequestInfo, init?: RequestInit) => Promise<Response>) {
    this.host = host
    this.headers = Object.keys(headers).map((k) => new XHR.Header(k, headers[k]))
    this.fetchImpl = fetchImpl
  }

  setHeaders(h: Array<XHR.Header>) {
    this.headers = h
  }

  handleError(e: XHR.XHRError): never {
    throw e
  }

  /**
   * Returns an instance of created classification.
   * @summary Create a classification with the current user
   * @param body
   */
  createTmpClassification(body?: Classification): Promise<Classification> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/classification` + '?ts=' + new Date().getTime()
    let headers = this.headers
    headers = headers.filter((h) => h.header !== 'Content-Type').concat(new XHR.Header('Content-Type', 'application/json'))
    return XHR.sendCommand('POST', _url, headers, _body, this.fetchImpl)
      .then((doc) => new Classification(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created classification.
   * @summary Create a classification with the current user
   * @param body
   */
  createTmpClassifications(body?: Array<Classification>): Promise<Array<Classification>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/classification/batch` + '?ts=' + new Date().getTime()
    let headers = this.headers
    headers = headers.filter((h) => h.header !== 'Content-Type').concat(new XHR.Header('Content-Type', 'application/json'))
    return XHR.sendCommand('POST', _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new Classification(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created contact.
   * @summary Create a contact with the current user
   * @param body
   */
  createTmpContact(body?: Contact): Promise<Contact> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/contact` + '?ts=' + new Date().getTime()
    let headers = this.headers
    headers = headers.filter((h) => h.header !== 'Content-Type').concat(new XHR.Header('Content-Type', 'application/json'))
    return XHR.sendCommand('POST', _url, headers, _body, this.fetchImpl)
      .then((doc) => new Contact(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created contact.
   * @summary Create a contact with the current user
   * @param body
   */
  createTmpContacts(body?: Array<Contact>): Promise<Array<Contact>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/contact/batch` + '?ts=' + new Date().getTime()
    let headers = this.headers
    headers = headers.filter((h) => h.header !== 'Content-Type').concat(new XHR.Header('Content-Type', 'application/json'))
    return XHR.sendCommand('POST', _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new Contact(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Nothing happens if the database already exists
   * @summary Create tmp database for current user
   */
  createTmpDatabase(): Promise<Unit> {
    let _body = null

    const _url = this.host + `/tmp` + '?ts=' + new Date().getTime()
    let headers = this.headers
    return XHR.sendCommand('POST', _url, headers, _body, this.fetchImpl)
      .then((doc) => new Unit(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created document.
   * @summary Create a document with the current user
   * @param body
   */
  createTmpDocument(body?: Document): Promise<Document> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/document` + '?ts=' + new Date().getTime()
    let headers = this.headers
    headers = headers.filter((h) => h.header !== 'Content-Type').concat(new XHR.Header('Content-Type', 'application/json'))
    return XHR.sendCommand('POST', _url, headers, _body, this.fetchImpl)
      .then((doc) => new Document(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created document.
   * @summary Create a document with the current user
   * @param body
   */
  createTmpDocuments(body?: Array<Document>): Promise<Array<Document>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/document/batch` + '?ts=' + new Date().getTime()
    let headers = this.headers
    headers = headers.filter((h) => h.header !== 'Content-Type').concat(new XHR.Header('Content-Type', 'application/json'))
    return XHR.sendCommand('POST', _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new Document(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created form.
   * @summary Create a form with the current user
   * @param body
   */
  createTmpForm(body?: Form): Promise<Form> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/form` + '?ts=' + new Date().getTime()
    let headers = this.headers
    headers = headers.filter((h) => h.header !== 'Content-Type').concat(new XHR.Header('Content-Type', 'application/json'))
    return XHR.sendCommand('POST', _url, headers, _body, this.fetchImpl)
      .then((doc) => new Form(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created form.
   * @summary Create a form with the current user
   * @param body
   */
  createTmpForms(body?: Array<Form>): Promise<Array<Form>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/form/batch` + '?ts=' + new Date().getTime()
    let headers = this.headers
    headers = headers.filter((h) => h.header !== 'Content-Type').concat(new XHR.Header('Content-Type', 'application/json'))
    return XHR.sendCommand('POST', _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new Form(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created healthElement.
   * @summary Create a healthElement with the current user
   * @param body
   */
  createTmpHealthElement(body?: HealthElement): Promise<HealthElement> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/healthElement` + '?ts=' + new Date().getTime()
    let headers = this.headers
    headers = headers.filter((h) => h.header !== 'Content-Type').concat(new XHR.Header('Content-Type', 'application/json'))
    return XHR.sendCommand('POST', _url, headers, _body, this.fetchImpl)
      .then((doc) => new HealthElement(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created healthElement.
   * @summary Create a healthElement with the current user
   * @param body
   */
  createTmpHealthElements(body?: Array<HealthElement>): Promise<Array<HealthElement>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/healthElement/batch` + '?ts=' + new Date().getTime()
    let headers = this.headers
    headers = headers.filter((h) => h.header !== 'Content-Type').concat(new XHR.Header('Content-Type', 'application/json'))
    return XHR.sendCommand('POST', _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new HealthElement(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created invoice.
   * @summary Create a invoice with the current user
   * @param body
   */
  createTmpInvoice(body?: Invoice): Promise<Invoice> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/invoice` + '?ts=' + new Date().getTime()
    let headers = this.headers
    headers = headers.filter((h) => h.header !== 'Content-Type').concat(new XHR.Header('Content-Type', 'application/json'))
    return XHR.sendCommand('POST', _url, headers, _body, this.fetchImpl)
      .then((doc) => new Invoice(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created invoice.
   * @summary Create a invoice with the current user
   * @param body
   */
  createTmpInvoices(body?: Array<Invoice>): Promise<Array<Invoice>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/invoice/batch` + '?ts=' + new Date().getTime()
    let headers = this.headers
    headers = headers.filter((h) => h.header !== 'Content-Type').concat(new XHR.Header('Content-Type', 'application/json'))
    return XHR.sendCommand('POST', _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new Invoice(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created message.
   * @summary Create a message with the current user
   * @param body
   */
  createTmpMessage(body?: Message): Promise<Message> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/message` + '?ts=' + new Date().getTime()
    let headers = this.headers
    headers = headers.filter((h) => h.header !== 'Content-Type').concat(new XHR.Header('Content-Type', 'application/json'))
    return XHR.sendCommand('POST', _url, headers, _body, this.fetchImpl)
      .then((doc) => new Message(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created message.
   * @summary Create a message with the current user
   * @param body
   */
  createTmpMessages(body?: Array<Message>): Promise<Array<Message>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/message/batch` + '?ts=' + new Date().getTime()
    let headers = this.headers
    headers = headers.filter((h) => h.header !== 'Content-Type').concat(new XHR.Header('Content-Type', 'application/json'))
    return XHR.sendCommand('POST', _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new Message(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created patient.
   * @summary Create a patient with the current user
   * @param body
   */
  createTmpPatient(body?: Patient): Promise<Patient> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/patient` + '?ts=' + new Date().getTime()
    let headers = this.headers
    headers = headers.filter((h) => h.header !== 'Content-Type').concat(new XHR.Header('Content-Type', 'application/json'))
    return XHR.sendCommand('POST', _url, headers, _body, this.fetchImpl)
      .then((doc) => new Patient(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created patient.
   * @summary Create a patient with the current user
   * @param body
   */
  createTmpPatients(body?: Array<Patient>): Promise<Array<Patient>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/patient/batch` + '?ts=' + new Date().getTime()
    let headers = this.headers
    headers = headers.filter((h) => h.header !== 'Content-Type').concat(new XHR.Header('Content-Type', 'application/json'))
    return XHR.sendCommand('POST', _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new Patient(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Response is a set containing the ID's of deleted items.
   * @summary Soft delete items.
   * @param body
   */
  deleteTmpItems(body?: Array<string>): Promise<Array<DocIdentifier>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/batch/delete` + '?ts=' + new Date().getTime()
    let headers = this.headers
    headers = headers.filter((h) => h.header !== 'Content-Type').concat(new XHR.Header('Content-Type', 'application/json'))
    return XHR.sendCommand('POST', _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new DocIdentifier(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Nothing happens if the database does not exists
   * @summary Destroy tmp database for current user
   */
  destroyTmpDatabase(): Promise<Unit> {
    let _body = null

    const _url = this.host + `/tmp` + '?ts=' + new Date().getTime()
    let headers = this.headers
    return XHR.sendCommand('DELETE', _url, headers, _body, this.fetchImpl)
      .then((doc) => new Unit(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of classification.
   * @summary Get a classification by id
   * @param id
   */
  getTmpClassification(id: string): Promise<Classification> {
    let _body = null

    const _url = this.host + `/tmp/classification/byId/${encodeURIComponent(String(id))}` + '?ts=' + new Date().getTime()
    let headers = this.headers
    return XHR.sendCommand('GET', _url, headers, _body, this.fetchImpl)
      .then((doc) => new Classification(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created classification.
   * @summary Create a classification with the current user
   * @param body
   */
  getTmpClassifications(body?: Array<string>): Promise<Array<Classification>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/classification/get` + '?ts=' + new Date().getTime()
    let headers = this.headers
    headers = headers.filter((h) => h.header !== 'Content-Type').concat(new XHR.Header('Content-Type', 'application/json'))
    return XHR.sendCommand('POST', _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new Classification(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of contact.
   * @summary Get a contact by id
   * @param id
   */
  getTmpContact(id: string): Promise<Contact> {
    let _body = null

    const _url = this.host + `/tmp/contact/byId/${encodeURIComponent(String(id))}` + '?ts=' + new Date().getTime()
    let headers = this.headers
    return XHR.sendCommand('GET', _url, headers, _body, this.fetchImpl)
      .then((doc) => new Contact(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created contact.
   * @summary Create a contact with the current user
   * @param body
   */
  getTmpContacts(body?: Array<string>): Promise<Array<Contact>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/contact/get` + '?ts=' + new Date().getTime()
    let headers = this.headers
    headers = headers.filter((h) => h.header !== 'Content-Type').concat(new XHR.Header('Content-Type', 'application/json'))
    return XHR.sendCommand('POST', _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new Contact(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of document.
   * @summary Get a document by id
   * @param id
   */
  getTmpDocument(id: string): Promise<Document> {
    let _body = null

    const _url = this.host + `/tmp/document/byId/${encodeURIComponent(String(id))}` + '?ts=' + new Date().getTime()
    let headers = this.headers
    return XHR.sendCommand('GET', _url, headers, _body, this.fetchImpl)
      .then((doc) => new Document(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created document.
   * @summary Create a document with the current user
   * @param body
   */
  getTmpDocuments(body?: Array<string>): Promise<Array<Document>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/document/get` + '?ts=' + new Date().getTime()
    let headers = this.headers
    headers = headers.filter((h) => h.header !== 'Content-Type').concat(new XHR.Header('Content-Type', 'application/json'))
    return XHR.sendCommand('POST', _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new Document(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of form.
   * @summary Get a form by id
   * @param id
   */
  getTmpForm(id: string): Promise<Form> {
    let _body = null

    const _url = this.host + `/tmp/byId/form/${encodeURIComponent(String(id))}` + '?ts=' + new Date().getTime()
    let headers = this.headers
    return XHR.sendCommand('GET', _url, headers, _body, this.fetchImpl)
      .then((doc) => new Form(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created form.
   * @summary Create a form with the current user
   * @param body
   */
  getTmpForms(body?: Array<string>): Promise<Array<Form>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/fget/list` + '?ts=' + new Date().getTime()
    let headers = this.headers
    headers = headers.filter((h) => h.header !== 'Content-Type').concat(new XHR.Header('Content-Type', 'application/json'))
    return XHR.sendCommand('POST', _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new Form(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of healthElement.
   * @summary Get a healthElement by id
   * @param id
   */
  getTmpHealthElement(id: string): Promise<HealthElement> {
    let _body = null

    const _url = this.host + `/tmp/healthElement/byId/${encodeURIComponent(String(id))}` + '?ts=' + new Date().getTime()
    let headers = this.headers
    return XHR.sendCommand('GET', _url, headers, _body, this.fetchImpl)
      .then((doc) => new HealthElement(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created healthElement.
   * @summary Create a healthElement with the current user
   * @param body
   */
  getTmpHealthElements(body?: Array<string>): Promise<Array<HealthElement>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/healthElement/get` + '?ts=' + new Date().getTime()
    let headers = this.headers
    headers = headers.filter((h) => h.header !== 'Content-Type').concat(new XHR.Header('Content-Type', 'application/json'))
    return XHR.sendCommand('POST', _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new HealthElement(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of invoice.
   * @summary Get a invoice by id
   * @param id
   */
  getTmpInvoice(id: string): Promise<Invoice> {
    let _body = null

    const _url = this.host + `/tmp/invoice/byId/${encodeURIComponent(String(id))}` + '?ts=' + new Date().getTime()
    let headers = this.headers
    return XHR.sendCommand('GET', _url, headers, _body, this.fetchImpl)
      .then((doc) => new Invoice(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created invoice.
   * @summary Create a invoice with the current user
   * @param body
   */
  getTmpInvoices(body?: Array<string>): Promise<Array<Invoice>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/invoice/get` + '?ts=' + new Date().getTime()
    let headers = this.headers
    headers = headers.filter((h) => h.header !== 'Content-Type').concat(new XHR.Header('Content-Type', 'application/json'))
    return XHR.sendCommand('POST', _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new Invoice(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of message.
   * @summary Get a message by id
   * @param id
   */
  getTmpMessage(id: string): Promise<Message> {
    let _body = null

    const _url = this.host + `/tmp/message/byId/${encodeURIComponent(String(id))}` + '?ts=' + new Date().getTime()
    let headers = this.headers
    return XHR.sendCommand('GET', _url, headers, _body, this.fetchImpl)
      .then((doc) => new Message(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created message.
   * @summary Create a message with the current user
   * @param body
   */
  getTmpMessages(body?: Array<string>): Promise<Array<Message>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/message/get` + '?ts=' + new Date().getTime()
    let headers = this.headers
    headers = headers.filter((h) => h.header !== 'Content-Type').concat(new XHR.Header('Content-Type', 'application/json'))
    return XHR.sendCommand('POST', _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new Message(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of patient.
   * @summary Get a patient by id
   * @param id
   */
  getTmpPatient(id: string): Promise<Patient> {
    let _body = null

    const _url = this.host + `/tmp/patient/byId/${encodeURIComponent(String(id))}` + '?ts=' + new Date().getTime()
    let headers = this.headers
    return XHR.sendCommand('GET', _url, headers, _body, this.fetchImpl)
      .then((doc) => new Patient(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created patient.
   * @summary Create a patient with the current user
   * @param body
   */
  getTmpPatients(body?: Array<string>): Promise<Array<Patient>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/patient/get` + '?ts=' + new Date().getTime()
    let headers = this.headers
    headers = headers.filter((h) => h.header !== 'Content-Type').concat(new XHR.Header('Content-Type', 'application/json'))
    return XHR.sendCommand('POST', _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new Patient(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns paginated classifications.
   * @summary List classifications with the current user
   * @param firstClassificationId
   * @param pageSize
   */
  listTmpClassifications(firstClassificationId: string, pageSize: number): Promise<PaginatedListClassification> {
    let _body = null

    const _url =
      this.host +
      `/tmp/classification/list` +
      '?ts=' +
      new Date().getTime() +
      (firstClassificationId ? '&firstClassificationId=' + encodeURIComponent(String(firstClassificationId)) : '') +
      (pageSize ? '&pageSize=' + encodeURIComponent(String(pageSize)) : '')
    let headers = this.headers
    return XHR.sendCommand('GET', _url, headers, _body, this.fetchImpl)
      .then((doc) => new PaginatedListClassification(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns paginated contacts.
   * @summary List contacts with the current user
   * @param firstContactId
   * @param pageSize
   */
  listTmpContacts(firstContactId: string, pageSize: number): Promise<PaginatedListInvoice> {
    let _body = null

    const _url =
      this.host +
      `/tmp/contact/list` +
      '?ts=' +
      new Date().getTime() +
      (firstContactId ? '&firstContactId=' + encodeURIComponent(String(firstContactId)) : '') +
      (pageSize ? '&pageSize=' + encodeURIComponent(String(pageSize)) : '')
    let headers = this.headers
    return XHR.sendCommand('GET', _url, headers, _body, this.fetchImpl)
      .then((doc) => new PaginatedListInvoice(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns paginated documents.
   * @summary List documents with the current user
   * @param firstDocumentId
   * @param pageSize
   */
  listTmpDocuments(firstDocumentId: string, pageSize: number): Promise<PaginatedListDocument> {
    let _body = null

    const _url =
      this.host +
      `/tmp/document/list` +
      '?ts=' +
      new Date().getTime() +
      (firstDocumentId ? '&firstDocumentId=' + encodeURIComponent(String(firstDocumentId)) : '') +
      (pageSize ? '&pageSize=' + encodeURIComponent(String(pageSize)) : '')
    let headers = this.headers
    return XHR.sendCommand('GET', _url, headers, _body, this.fetchImpl)
      .then((doc) => new PaginatedListDocument(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns paginated forms.
   * @summary List forms with the current user
   * @param firstFormId
   * @param pageSize
   */
  listTmpForms(firstFormId: string, pageSize: number): Promise<PaginatedListForm> {
    let _body = null

    const _url =
      this.host +
      `/tmp/form/list` +
      '?ts=' +
      new Date().getTime() +
      (firstFormId ? '&firstFormId=' + encodeURIComponent(String(firstFormId)) : '') +
      (pageSize ? '&pageSize=' + encodeURIComponent(String(pageSize)) : '')
    let headers = this.headers
    return XHR.sendCommand('GET', _url, headers, _body, this.fetchImpl)
      .then((doc) => new PaginatedListForm(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns paginated healthElements.
   * @summary List healthElements with the current user
   * @param firstHealthElementId
   * @param pageSize
   */
  listTmpHealthElements(firstHealthElementId: string, pageSize: number): Promise<PaginatedListHealthElement> {
    let _body = null

    const _url =
      this.host +
      `/tmp/healthElement/list` +
      '?ts=' +
      new Date().getTime() +
      (firstHealthElementId ? '&firstHealthElementId=' + encodeURIComponent(String(firstHealthElementId)) : '') +
      (pageSize ? '&pageSize=' + encodeURIComponent(String(pageSize)) : '')
    let headers = this.headers
    return XHR.sendCommand('GET', _url, headers, _body, this.fetchImpl)
      .then((doc) => new PaginatedListHealthElement(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns paginated invoices.
   * @summary List invoices with the current user
   * @param firstInvoiceId
   * @param pageSize
   */
  listTmpInvoices(firstInvoiceId: string, pageSize: number): Promise<PaginatedListInvoice> {
    let _body = null

    const _url =
      this.host +
      `/tmp/invoice/list` +
      '?ts=' +
      new Date().getTime() +
      (firstInvoiceId ? '&firstInvoiceId=' + encodeURIComponent(String(firstInvoiceId)) : '') +
      (pageSize ? '&pageSize=' + encodeURIComponent(String(pageSize)) : '')
    let headers = this.headers
    return XHR.sendCommand('GET', _url, headers, _body, this.fetchImpl)
      .then((doc) => new PaginatedListInvoice(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns paginated messages.
   * @summary List messages with the current user
   * @param firstMessageId
   * @param pageSize
   */
  listTmpMessages(firstMessageId: string, pageSize: number): Promise<PaginatedListInvoice> {
    let _body = null

    const _url =
      this.host +
      `/tmp/message/list` +
      '?ts=' +
      new Date().getTime() +
      (firstMessageId ? '&firstMessageId=' + encodeURIComponent(String(firstMessageId)) : '') +
      (pageSize ? '&pageSize=' + encodeURIComponent(String(pageSize)) : '')
    let headers = this.headers
    return XHR.sendCommand('GET', _url, headers, _body, this.fetchImpl)
      .then((doc) => new PaginatedListInvoice(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns paginated patients.
   * @summary List patients with the current user
   * @param firstPatientId
   * @param pageSize
   */
  listTmpPatients(firstPatientId: string, pageSize: number): Promise<PaginatedListPatient> {
    let _body = null

    const _url =
      this.host +
      `/tmp/patient/list` +
      '?ts=' +
      new Date().getTime() +
      (firstPatientId ? '&firstPatientId=' + encodeURIComponent(String(firstPatientId)) : '') +
      (pageSize ? '&pageSize=' + encodeURIComponent(String(pageSize)) : '')
    let headers = this.headers
    return XHR.sendCommand('GET', _url, headers, _body, this.fetchImpl)
      .then((doc) => new PaginatedListPatient(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns the modified classification.
   * @summary Modify a classification
   * @param body
   */
  modifyTmpClassification(body?: Classification): Promise<Classification> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/classification` + '?ts=' + new Date().getTime()
    let headers = this.headers
    headers = headers.filter((h) => h.header !== 'Content-Type').concat(new XHR.Header('Content-Type', 'application/json'))
    return XHR.sendCommand('PUT', _url, headers, _body, this.fetchImpl)
      .then((doc) => new Classification(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns the modified healthcare elements.
   * @summary Modify a batch of healthcare elements
   * @param body
   */
  modifyTmpClassifications(body?: Array<Classification>): Promise<Array<Classification>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/classification/batch` + '?ts=' + new Date().getTime()
    let headers = this.headers
    headers = headers.filter((h) => h.header !== 'Content-Type').concat(new XHR.Header('Content-Type', 'application/json'))
    return XHR.sendCommand('PUT', _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new Classification(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns the modified contact.
   * @summary Modify a contact
   * @param body
   */
  modifyTmpContact(body?: Contact): Promise<Contact> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/contact` + '?ts=' + new Date().getTime()
    let headers = this.headers
    headers = headers.filter((h) => h.header !== 'Content-Type').concat(new XHR.Header('Content-Type', 'application/json'))
    return XHR.sendCommand('PUT', _url, headers, _body, this.fetchImpl)
      .then((doc) => new Contact(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns the modified healthcare elements.
   * @summary Modify a batch of healthcare elements
   * @param body
   */
  modifyTmpContacts(body?: Array<Contact>): Promise<Array<Contact>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/contact/batch` + '?ts=' + new Date().getTime()
    let headers = this.headers
    headers = headers.filter((h) => h.header !== 'Content-Type').concat(new XHR.Header('Content-Type', 'application/json'))
    return XHR.sendCommand('PUT', _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new Contact(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns the modified document.
   * @summary Modify a document
   * @param body
   */
  modifyTmpDocument(body?: Document): Promise<Document> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/document` + '?ts=' + new Date().getTime()
    let headers = this.headers
    headers = headers.filter((h) => h.header !== 'Content-Type').concat(new XHR.Header('Content-Type', 'application/json'))
    return XHR.sendCommand('PUT', _url, headers, _body, this.fetchImpl)
      .then((doc) => new Document(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns the modified healthcare elements.
   * @summary Modify a batch of healthcare elements
   * @param body
   */
  modifyTmpDocuments(body?: Array<Document>): Promise<Array<Document>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/document/batch` + '?ts=' + new Date().getTime()
    let headers = this.headers
    headers = headers.filter((h) => h.header !== 'Content-Type').concat(new XHR.Header('Content-Type', 'application/json'))
    return XHR.sendCommand('PUT', _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new Document(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns the modified form.
   * @summary Modify a form
   * @param body
   */
  modifyTmpForm(body?: Form): Promise<Form> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/form` + '?ts=' + new Date().getTime()
    let headers = this.headers
    headers = headers.filter((h) => h.header !== 'Content-Type').concat(new XHR.Header('Content-Type', 'application/json'))
    return XHR.sendCommand('PUT', _url, headers, _body, this.fetchImpl)
      .then((doc) => new Form(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns the modified healthcare elements.
   * @summary Modify a batch of healthcare elements
   * @param body
   */
  modifyTmpForms(body?: Array<Form>): Promise<Array<Form>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/form/batch` + '?ts=' + new Date().getTime()
    let headers = this.headers
    headers = headers.filter((h) => h.header !== 'Content-Type').concat(new XHR.Header('Content-Type', 'application/json'))
    return XHR.sendCommand('PUT', _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new Form(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns the modified healthElement.
   * @summary Modify a healthElement
   * @param body
   */
  modifyTmpHealthElement(body?: HealthElement): Promise<HealthElement> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/healthElement` + '?ts=' + new Date().getTime()
    let headers = this.headers
    headers = headers.filter((h) => h.header !== 'Content-Type').concat(new XHR.Header('Content-Type', 'application/json'))
    return XHR.sendCommand('PUT', _url, headers, _body, this.fetchImpl)
      .then((doc) => new HealthElement(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns the modified healthcare elements.
   * @summary Modify a batch of healthcare elements
   * @param body
   */
  modifyTmpHealthElements(body?: Array<HealthElement>): Promise<Array<HealthElement>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/healthElement/batch` + '?ts=' + new Date().getTime()
    let headers = this.headers
    headers = headers.filter((h) => h.header !== 'Content-Type').concat(new XHR.Header('Content-Type', 'application/json'))
    return XHR.sendCommand('PUT', _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new HealthElement(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns the modified invoice.
   * @summary Modify a invoice
   * @param body
   */
  modifyTmpInvoice(body?: Invoice): Promise<Invoice> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/invoice` + '?ts=' + new Date().getTime()
    let headers = this.headers
    headers = headers.filter((h) => h.header !== 'Content-Type').concat(new XHR.Header('Content-Type', 'application/json'))
    return XHR.sendCommand('PUT', _url, headers, _body, this.fetchImpl)
      .then((doc) => new Invoice(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns the modified healthcare elements.
   * @summary Modify a batch of healthcare elements
   * @param body
   */
  modifyTmpInvoices(body?: Array<Invoice>): Promise<Array<Invoice>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/invoice/batch` + '?ts=' + new Date().getTime()
    let headers = this.headers
    headers = headers.filter((h) => h.header !== 'Content-Type').concat(new XHR.Header('Content-Type', 'application/json'))
    return XHR.sendCommand('PUT', _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new Invoice(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns the modified message.
   * @summary Modify a message
   * @param body
   */
  modifyTmpMessage(body?: Message): Promise<Message> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/message` + '?ts=' + new Date().getTime()
    let headers = this.headers
    headers = headers.filter((h) => h.header !== 'Content-Type').concat(new XHR.Header('Content-Type', 'application/json'))
    return XHR.sendCommand('PUT', _url, headers, _body, this.fetchImpl)
      .then((doc) => new Message(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns the modified healthcare elements.
   * @summary Modify a batch of healthcare elements
   * @param body
   */
  modifyTmpMessages(body?: Array<Message>): Promise<Array<Message>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/message/batch` + '?ts=' + new Date().getTime()
    let headers = this.headers
    headers = headers.filter((h) => h.header !== 'Content-Type').concat(new XHR.Header('Content-Type', 'application/json'))
    return XHR.sendCommand('PUT', _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new Message(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns the modified patient.
   * @summary Modify a patient
   * @param body
   */
  modifyTmpPatient(body?: Patient): Promise<Patient> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/patient` + '?ts=' + new Date().getTime()
    let headers = this.headers
    headers = headers.filter((h) => h.header !== 'Content-Type').concat(new XHR.Header('Content-Type', 'application/json'))
    return XHR.sendCommand('PUT', _url, headers, _body, this.fetchImpl)
      .then((doc) => new Patient(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns the modified healthcare elements.
   * @summary Modify a batch of healthcare elements
   * @param body
   */
  modifyTmpPatients(body?: Array<Patient>): Promise<Array<Patient>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/patient/batch` + '?ts=' + new Date().getTime()
    let headers = this.headers
    headers = headers.filter((h) => h.header !== 'Content-Type').concat(new XHR.Header('Content-Type', 'application/json'))
    return XHR.sendCommand('PUT', _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new Patient(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Response is a set containing the ID's of deleted items.
   * @summary Hard delete items.
   * @param body
   */
  purgeTmpItems(body?: Array<string>): Promise<Array<DocIdentifier>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/batch/purge` + '?ts=' + new Date().getTime()
    let headers = this.headers
    headers = headers.filter((h) => h.header !== 'Content-Type').concat(new XHR.Header('Content-Type', 'application/json'))
    return XHR.sendCommand('POST', _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new DocIdentifier(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   *
   * @param body
   * @param from
   */
  replicateToTmpDatabase(from: string, body?: Array<string>): Promise<Unit> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/replicate/from/${encodeURIComponent(String(from))}` + '?ts=' + new Date().getTime()
    let headers = this.headers
    headers = headers.filter((h) => h.header !== 'Content-Type').concat(new XHR.Header('Content-Type', 'application/json'))
    return XHR.sendCommand('POST', _url, headers, _body, this.fetchImpl)
      .then((doc) => new Unit(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }
}
