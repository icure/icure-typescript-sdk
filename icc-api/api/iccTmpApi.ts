/**
 * iCure Cloud API Documentation
 * Spring shop sample application
 *
 * OpenAPI spec version: v0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import { XHR } from "./XHR"
import { ClassificationDto } from "../model/ClassificationDto"
import { ContactDto } from "../model/ContactDto"
import { DocIdentifier } from "../model/DocIdentifier"
import { DocumentDto } from "../model/DocumentDto"
import { FormDto } from "../model/FormDto"
import { HealthElementDto } from "../model/HealthElementDto"
import { InvoiceDto } from "../model/InvoiceDto"
import { MessageDto } from "../model/MessageDto"
import { PaginatedListClassificationDto } from "../model/PaginatedListClassificationDto"
import { PaginatedListDocumentDto } from "../model/PaginatedListDocumentDto"
import { PaginatedListFormDto } from "../model/PaginatedListFormDto"
import { PaginatedListHealthElementDto } from "../model/PaginatedListHealthElementDto"
import { PaginatedListInvoiceDto } from "../model/PaginatedListInvoiceDto"
import { PaginatedListPatientDto } from "../model/PaginatedListPatientDto"
import { PatientDto } from "../model/PatientDto"
import { Unit } from "../model/Unit"

export class iccTmpApi {
  host: string
  headers: Array<XHR.Header>
  fetchImpl?: (input: RequestInfo, init?: RequestInit) => Promise<Response>

  constructor(
    host: string,
    headers: any,
    fetchImpl?: (input: RequestInfo, init?: RequestInit) => Promise<Response>
  ) {
    this.host = host
    this.headers = Object.keys(headers).map((k) => new XHR.Header(k, headers[k]))
    this.fetchImpl = fetchImpl
  }

  setHeaders(h: Array<XHR.Header>) {
    this.headers = h
  }

  handleError(e: XHR.XHRError): never {
    throw e
  }

  /**
   * Returns an instance of created classification.
   * @summary Create a classification with the current user
   * @param body
   */
  createTmpClassification(body?: ClassificationDto): Promise<ClassificationDto> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/classification` + "?ts=" + new Date().getTime()
    let headers = this.headers
    headers = headers
      .filter((h) => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "application/json"))
    return XHR.sendCommand("POST", _url, headers, _body, this.fetchImpl)
      .then((doc) => new ClassificationDto(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created classification.
   * @summary Create a classification with the current user
   * @param body
   */
  createTmpClassifications(body?: Array<ClassificationDto>): Promise<Array<ClassificationDto>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/classification/batch` + "?ts=" + new Date().getTime()
    let headers = this.headers
    headers = headers
      .filter((h) => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "application/json"))
    return XHR.sendCommand("POST", _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new ClassificationDto(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created contact.
   * @summary Create a contact with the current user
   * @param body
   */
  createTmpContact(body?: ContactDto): Promise<ContactDto> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/contact` + "?ts=" + new Date().getTime()
    let headers = this.headers
    headers = headers
      .filter((h) => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "application/json"))
    return XHR.sendCommand("POST", _url, headers, _body, this.fetchImpl)
      .then((doc) => new ContactDto(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created contact.
   * @summary Create a contact with the current user
   * @param body
   */
  createTmpContacts(body?: Array<ContactDto>): Promise<Array<ContactDto>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/contact/batch` + "?ts=" + new Date().getTime()
    let headers = this.headers
    headers = headers
      .filter((h) => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "application/json"))
    return XHR.sendCommand("POST", _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new ContactDto(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Nothing happens if the database already exists
   * @summary Create tmp database for current user
   */
  createTmpDatabase(): Promise<Unit> {
    let _body = null

    const _url = this.host + `/tmp` + "?ts=" + new Date().getTime()
    let headers = this.headers
    return XHR.sendCommand("POST", _url, headers, _body, this.fetchImpl)
      .then((doc) => new Unit(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created document.
   * @summary Create a document with the current user
   * @param body
   */
  createTmpDocument(body?: DocumentDto): Promise<DocumentDto> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/document` + "?ts=" + new Date().getTime()
    let headers = this.headers
    headers = headers
      .filter((h) => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "application/json"))
    return XHR.sendCommand("POST", _url, headers, _body, this.fetchImpl)
      .then((doc) => new DocumentDto(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created document.
   * @summary Create a document with the current user
   * @param body
   */
  createTmpDocuments(body?: Array<DocumentDto>): Promise<Array<DocumentDto>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/document/batch` + "?ts=" + new Date().getTime()
    let headers = this.headers
    headers = headers
      .filter((h) => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "application/json"))
    return XHR.sendCommand("POST", _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new DocumentDto(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created form.
   * @summary Create a form with the current user
   * @param body
   */
  createTmpForm(body?: FormDto): Promise<FormDto> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/form` + "?ts=" + new Date().getTime()
    let headers = this.headers
    headers = headers
      .filter((h) => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "application/json"))
    return XHR.sendCommand("POST", _url, headers, _body, this.fetchImpl)
      .then((doc) => new FormDto(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created form.
   * @summary Create a form with the current user
   * @param body
   */
  createTmpForms(body?: Array<FormDto>): Promise<Array<FormDto>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/form/batch` + "?ts=" + new Date().getTime()
    let headers = this.headers
    headers = headers
      .filter((h) => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "application/json"))
    return XHR.sendCommand("POST", _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new FormDto(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created healthElement.
   * @summary Create a healthElement with the current user
   * @param body
   */
  createTmpHealthElement(body?: HealthElementDto): Promise<HealthElementDto> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/healthElement` + "?ts=" + new Date().getTime()
    let headers = this.headers
    headers = headers
      .filter((h) => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "application/json"))
    return XHR.sendCommand("POST", _url, headers, _body, this.fetchImpl)
      .then((doc) => new HealthElementDto(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created healthElement.
   * @summary Create a healthElement with the current user
   * @param body
   */
  createTmpHealthElements(body?: Array<HealthElementDto>): Promise<Array<HealthElementDto>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/healthElement/batch` + "?ts=" + new Date().getTime()
    let headers = this.headers
    headers = headers
      .filter((h) => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "application/json"))
    return XHR.sendCommand("POST", _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new HealthElementDto(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created invoice.
   * @summary Create a invoice with the current user
   * @param body
   */
  createTmpInvoice(body?: InvoiceDto): Promise<InvoiceDto> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/invoice` + "?ts=" + new Date().getTime()
    let headers = this.headers
    headers = headers
      .filter((h) => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "application/json"))
    return XHR.sendCommand("POST", _url, headers, _body, this.fetchImpl)
      .then((doc) => new InvoiceDto(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created invoice.
   * @summary Create a invoice with the current user
   * @param body
   */
  createTmpInvoices(body?: Array<InvoiceDto>): Promise<Array<InvoiceDto>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/invoice/batch` + "?ts=" + new Date().getTime()
    let headers = this.headers
    headers = headers
      .filter((h) => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "application/json"))
    return XHR.sendCommand("POST", _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new InvoiceDto(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created message.
   * @summary Create a message with the current user
   * @param body
   */
  createTmpMessage(body?: MessageDto): Promise<MessageDto> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/message` + "?ts=" + new Date().getTime()
    let headers = this.headers
    headers = headers
      .filter((h) => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "application/json"))
    return XHR.sendCommand("POST", _url, headers, _body, this.fetchImpl)
      .then((doc) => new MessageDto(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created message.
   * @summary Create a message with the current user
   * @param body
   */
  createTmpMessages(body?: Array<MessageDto>): Promise<Array<MessageDto>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/message/batch` + "?ts=" + new Date().getTime()
    let headers = this.headers
    headers = headers
      .filter((h) => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "application/json"))
    return XHR.sendCommand("POST", _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new MessageDto(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created patient.
   * @summary Create a patient with the current user
   * @param body
   */
  createTmpPatient(body?: PatientDto): Promise<PatientDto> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/patient` + "?ts=" + new Date().getTime()
    let headers = this.headers
    headers = headers
      .filter((h) => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "application/json"))
    return XHR.sendCommand("POST", _url, headers, _body, this.fetchImpl)
      .then((doc) => new PatientDto(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created patient.
   * @summary Create a patient with the current user
   * @param body
   */
  createTmpPatients(body?: Array<PatientDto>): Promise<Array<PatientDto>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/patient/batch` + "?ts=" + new Date().getTime()
    let headers = this.headers
    headers = headers
      .filter((h) => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "application/json"))
    return XHR.sendCommand("POST", _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new PatientDto(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Response is a set containing the ID's of deleted items.
   * @summary Soft delete items.
   * @param body
   */
  deleteTmpItems(body?: Array<string>): Promise<Array<DocIdentifier>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/batch/delete` + "?ts=" + new Date().getTime()
    let headers = this.headers
    headers = headers
      .filter((h) => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "application/json"))
    return XHR.sendCommand("POST", _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new DocIdentifier(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Nothing happens if the database does not exists
   * @summary Destroy tmp database for current user
   */
  destroyTmpDatabase(): Promise<Unit> {
    let _body = null

    const _url = this.host + `/tmp` + "?ts=" + new Date().getTime()
    let headers = this.headers
    return XHR.sendCommand("DELETE", _url, headers, _body, this.fetchImpl)
      .then((doc) => new Unit(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of classification.
   * @summary Get a classification by id
   * @param id
   */
  getTmpClassification(id: string): Promise<ClassificationDto> {
    let _body = null

    const _url =
      this.host +
      `/tmp/classification/byId/${encodeURIComponent(String(id))}` +
      "?ts=" +
      new Date().getTime()
    let headers = this.headers
    return XHR.sendCommand("GET", _url, headers, _body, this.fetchImpl)
      .then((doc) => new ClassificationDto(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created classification.
   * @summary Create a classification with the current user
   * @param body
   */
  getTmpClassifications(body?: Array<string>): Promise<Array<ClassificationDto>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/classification/get` + "?ts=" + new Date().getTime()
    let headers = this.headers
    headers = headers
      .filter((h) => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "application/json"))
    return XHR.sendCommand("POST", _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new ClassificationDto(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of contact.
   * @summary Get a contact by id
   * @param id
   */
  getTmpContact(id: string): Promise<ContactDto> {
    let _body = null

    const _url =
      this.host +
      `/tmp/contact/byId/${encodeURIComponent(String(id))}` +
      "?ts=" +
      new Date().getTime()
    let headers = this.headers
    return XHR.sendCommand("GET", _url, headers, _body, this.fetchImpl)
      .then((doc) => new ContactDto(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created contact.
   * @summary Create a contact with the current user
   * @param body
   */
  getTmpContacts(body?: Array<string>): Promise<Array<ContactDto>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/contact/get` + "?ts=" + new Date().getTime()
    let headers = this.headers
    headers = headers
      .filter((h) => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "application/json"))
    return XHR.sendCommand("POST", _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new ContactDto(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of document.
   * @summary Get a document by id
   * @param id
   */
  getTmpDocument(id: string): Promise<DocumentDto> {
    let _body = null

    const _url =
      this.host +
      `/tmp/document/byId/${encodeURIComponent(String(id))}` +
      "?ts=" +
      new Date().getTime()
    let headers = this.headers
    return XHR.sendCommand("GET", _url, headers, _body, this.fetchImpl)
      .then((doc) => new DocumentDto(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created document.
   * @summary Create a document with the current user
   * @param body
   */
  getTmpDocuments(body?: Array<string>): Promise<Array<DocumentDto>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/document/get` + "?ts=" + new Date().getTime()
    let headers = this.headers
    headers = headers
      .filter((h) => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "application/json"))
    return XHR.sendCommand("POST", _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new DocumentDto(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of form.
   * @summary Get a form by id
   * @param id
   */
  getTmpForm(id: string): Promise<FormDto> {
    let _body = null

    const _url =
      this.host + `/tmp/byId/form/${encodeURIComponent(String(id))}` + "?ts=" + new Date().getTime()
    let headers = this.headers
    return XHR.sendCommand("GET", _url, headers, _body, this.fetchImpl)
      .then((doc) => new FormDto(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created form.
   * @summary Create a form with the current user
   * @param body
   */
  getTmpForms(body?: Array<string>): Promise<Array<FormDto>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/fget/list` + "?ts=" + new Date().getTime()
    let headers = this.headers
    headers = headers
      .filter((h) => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "application/json"))
    return XHR.sendCommand("POST", _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new FormDto(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of healthElement.
   * @summary Get a healthElement by id
   * @param id
   */
  getTmpHealthElement(id: string): Promise<HealthElementDto> {
    let _body = null

    const _url =
      this.host +
      `/tmp/healthElement/byId/${encodeURIComponent(String(id))}` +
      "?ts=" +
      new Date().getTime()
    let headers = this.headers
    return XHR.sendCommand("GET", _url, headers, _body, this.fetchImpl)
      .then((doc) => new HealthElementDto(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created healthElement.
   * @summary Create a healthElement with the current user
   * @param body
   */
  getTmpHealthElements(body?: Array<string>): Promise<Array<HealthElementDto>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/healthElement/get` + "?ts=" + new Date().getTime()
    let headers = this.headers
    headers = headers
      .filter((h) => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "application/json"))
    return XHR.sendCommand("POST", _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new HealthElementDto(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of invoice.
   * @summary Get a invoice by id
   * @param id
   */
  getTmpInvoice(id: string): Promise<InvoiceDto> {
    let _body = null

    const _url =
      this.host +
      `/tmp/invoice/byId/${encodeURIComponent(String(id))}` +
      "?ts=" +
      new Date().getTime()
    let headers = this.headers
    return XHR.sendCommand("GET", _url, headers, _body, this.fetchImpl)
      .then((doc) => new InvoiceDto(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created invoice.
   * @summary Create a invoice with the current user
   * @param body
   */
  getTmpInvoices(body?: Array<string>): Promise<Array<InvoiceDto>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/invoice/get` + "?ts=" + new Date().getTime()
    let headers = this.headers
    headers = headers
      .filter((h) => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "application/json"))
    return XHR.sendCommand("POST", _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new InvoiceDto(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of message.
   * @summary Get a message by id
   * @param id
   */
  getTmpMessage(id: string): Promise<MessageDto> {
    let _body = null

    const _url =
      this.host +
      `/tmp/message/byId/${encodeURIComponent(String(id))}` +
      "?ts=" +
      new Date().getTime()
    let headers = this.headers
    return XHR.sendCommand("GET", _url, headers, _body, this.fetchImpl)
      .then((doc) => new MessageDto(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created message.
   * @summary Create a message with the current user
   * @param body
   */
  getTmpMessages(body?: Array<string>): Promise<Array<MessageDto>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/message/get` + "?ts=" + new Date().getTime()
    let headers = this.headers
    headers = headers
      .filter((h) => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "application/json"))
    return XHR.sendCommand("POST", _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new MessageDto(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of patient.
   * @summary Get a patient by id
   * @param id
   */
  getTmpPatient(id: string): Promise<PatientDto> {
    let _body = null

    const _url =
      this.host +
      `/tmp/patient/byId/${encodeURIComponent(String(id))}` +
      "?ts=" +
      new Date().getTime()
    let headers = this.headers
    return XHR.sendCommand("GET", _url, headers, _body, this.fetchImpl)
      .then((doc) => new PatientDto(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns an instance of created patient.
   * @summary Create a patient with the current user
   * @param body
   */
  getTmpPatients(body?: Array<string>): Promise<Array<PatientDto>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/patient/get` + "?ts=" + new Date().getTime()
    let headers = this.headers
    headers = headers
      .filter((h) => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "application/json"))
    return XHR.sendCommand("POST", _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new PatientDto(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns paginated classifications.
   * @summary List classifications with the current user
   * @param firstClassificationId
   * @param pageSize
   */
  listTmpClassifications(
    firstClassificationId: string,
    pageSize: number
  ): Promise<PaginatedListClassificationDto> {
    let _body = null

    const _url =
      this.host +
      `/tmp/classification/list` +
      "?ts=" +
      new Date().getTime() +
      (firstClassificationId
        ? "&firstClassificationId=" + encodeURIComponent(String(firstClassificationId))
        : "") +
      (pageSize ? "&pageSize=" + encodeURIComponent(String(pageSize)) : "")
    let headers = this.headers
    return XHR.sendCommand("GET", _url, headers, _body, this.fetchImpl)
      .then((doc) => new PaginatedListClassificationDto(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns paginated contacts.
   * @summary List contacts with the current user
   * @param firstContactId
   * @param pageSize
   */
  listTmpContacts(firstContactId: string, pageSize: number): Promise<PaginatedListInvoiceDto> {
    let _body = null

    const _url =
      this.host +
      `/tmp/contact/list` +
      "?ts=" +
      new Date().getTime() +
      (firstContactId ? "&firstContactId=" + encodeURIComponent(String(firstContactId)) : "") +
      (pageSize ? "&pageSize=" + encodeURIComponent(String(pageSize)) : "")
    let headers = this.headers
    return XHR.sendCommand("GET", _url, headers, _body, this.fetchImpl)
      .then((doc) => new PaginatedListInvoiceDto(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns paginated documents.
   * @summary List documents with the current user
   * @param firstDocumentId
   * @param pageSize
   */
  listTmpDocuments(firstDocumentId: string, pageSize: number): Promise<PaginatedListDocumentDto> {
    let _body = null

    const _url =
      this.host +
      `/tmp/document/list` +
      "?ts=" +
      new Date().getTime() +
      (firstDocumentId ? "&firstDocumentId=" + encodeURIComponent(String(firstDocumentId)) : "") +
      (pageSize ? "&pageSize=" + encodeURIComponent(String(pageSize)) : "")
    let headers = this.headers
    return XHR.sendCommand("GET", _url, headers, _body, this.fetchImpl)
      .then((doc) => new PaginatedListDocumentDto(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns paginated forms.
   * @summary List forms with the current user
   * @param firstFormId
   * @param pageSize
   */
  listTmpForms(firstFormId: string, pageSize: number): Promise<PaginatedListFormDto> {
    let _body = null

    const _url =
      this.host +
      `/tmp/form/list` +
      "?ts=" +
      new Date().getTime() +
      (firstFormId ? "&firstFormId=" + encodeURIComponent(String(firstFormId)) : "") +
      (pageSize ? "&pageSize=" + encodeURIComponent(String(pageSize)) : "")
    let headers = this.headers
    return XHR.sendCommand("GET", _url, headers, _body, this.fetchImpl)
      .then((doc) => new PaginatedListFormDto(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns paginated healthElements.
   * @summary List healthElements with the current user
   * @param firstHealthElementId
   * @param pageSize
   */
  listTmpHealthElements(
    firstHealthElementId: string,
    pageSize: number
  ): Promise<PaginatedListHealthElementDto> {
    let _body = null

    const _url =
      this.host +
      `/tmp/healthElement/list` +
      "?ts=" +
      new Date().getTime() +
      (firstHealthElementId
        ? "&firstHealthElementId=" + encodeURIComponent(String(firstHealthElementId))
        : "") +
      (pageSize ? "&pageSize=" + encodeURIComponent(String(pageSize)) : "")
    let headers = this.headers
    return XHR.sendCommand("GET", _url, headers, _body, this.fetchImpl)
      .then((doc) => new PaginatedListHealthElementDto(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns paginated invoices.
   * @summary List invoices with the current user
   * @param firstInvoiceId
   * @param pageSize
   */
  listTmpInvoices(firstInvoiceId: string, pageSize: number): Promise<PaginatedListInvoiceDto> {
    let _body = null

    const _url =
      this.host +
      `/tmp/invoice/list` +
      "?ts=" +
      new Date().getTime() +
      (firstInvoiceId ? "&firstInvoiceId=" + encodeURIComponent(String(firstInvoiceId)) : "") +
      (pageSize ? "&pageSize=" + encodeURIComponent(String(pageSize)) : "")
    let headers = this.headers
    return XHR.sendCommand("GET", _url, headers, _body, this.fetchImpl)
      .then((doc) => new PaginatedListInvoiceDto(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns paginated messages.
   * @summary List messages with the current user
   * @param firstMessageId
   * @param pageSize
   */
  listTmpMessages(firstMessageId: string, pageSize: number): Promise<PaginatedListInvoiceDto> {
    let _body = null

    const _url =
      this.host +
      `/tmp/message/list` +
      "?ts=" +
      new Date().getTime() +
      (firstMessageId ? "&firstMessageId=" + encodeURIComponent(String(firstMessageId)) : "") +
      (pageSize ? "&pageSize=" + encodeURIComponent(String(pageSize)) : "")
    let headers = this.headers
    return XHR.sendCommand("GET", _url, headers, _body, this.fetchImpl)
      .then((doc) => new PaginatedListInvoiceDto(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns paginated patients.
   * @summary List patients with the current user
   * @param firstPatientId
   * @param pageSize
   */
  listTmpPatients(firstPatientId: string, pageSize: number): Promise<PaginatedListPatientDto> {
    let _body = null

    const _url =
      this.host +
      `/tmp/patient/list` +
      "?ts=" +
      new Date().getTime() +
      (firstPatientId ? "&firstPatientId=" + encodeURIComponent(String(firstPatientId)) : "") +
      (pageSize ? "&pageSize=" + encodeURIComponent(String(pageSize)) : "")
    let headers = this.headers
    return XHR.sendCommand("GET", _url, headers, _body, this.fetchImpl)
      .then((doc) => new PaginatedListPatientDto(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns the modified classification.
   * @summary Modify a classification
   * @param body
   */
  modifyTmpClassification(body?: ClassificationDto): Promise<ClassificationDto> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/classification` + "?ts=" + new Date().getTime()
    let headers = this.headers
    headers = headers
      .filter((h) => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "application/json"))
    return XHR.sendCommand("PUT", _url, headers, _body, this.fetchImpl)
      .then((doc) => new ClassificationDto(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns the modified healthcare elements.
   * @summary Modify a batch of healthcare elements
   * @param body
   */
  modifyTmpClassifications(body?: Array<ClassificationDto>): Promise<Array<ClassificationDto>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/classification/batch` + "?ts=" + new Date().getTime()
    let headers = this.headers
    headers = headers
      .filter((h) => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "application/json"))
    return XHR.sendCommand("PUT", _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new ClassificationDto(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns the modified contact.
   * @summary Modify a contact
   * @param body
   */
  modifyTmpContact(body?: ContactDto): Promise<ContactDto> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/contact` + "?ts=" + new Date().getTime()
    let headers = this.headers
    headers = headers
      .filter((h) => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "application/json"))
    return XHR.sendCommand("PUT", _url, headers, _body, this.fetchImpl)
      .then((doc) => new ContactDto(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns the modified healthcare elements.
   * @summary Modify a batch of healthcare elements
   * @param body
   */
  modifyTmpContacts(body?: Array<ContactDto>): Promise<Array<ContactDto>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/contact/batch` + "?ts=" + new Date().getTime()
    let headers = this.headers
    headers = headers
      .filter((h) => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "application/json"))
    return XHR.sendCommand("PUT", _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new ContactDto(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns the modified document.
   * @summary Modify a document
   * @param body
   */
  modifyTmpDocument(body?: DocumentDto): Promise<DocumentDto> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/document` + "?ts=" + new Date().getTime()
    let headers = this.headers
    headers = headers
      .filter((h) => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "application/json"))
    return XHR.sendCommand("PUT", _url, headers, _body, this.fetchImpl)
      .then((doc) => new DocumentDto(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns the modified healthcare elements.
   * @summary Modify a batch of healthcare elements
   * @param body
   */
  modifyTmpDocuments(body?: Array<DocumentDto>): Promise<Array<DocumentDto>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/document/batch` + "?ts=" + new Date().getTime()
    let headers = this.headers
    headers = headers
      .filter((h) => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "application/json"))
    return XHR.sendCommand("PUT", _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new DocumentDto(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns the modified form.
   * @summary Modify a form
   * @param body
   */
  modifyTmpForm(body?: FormDto): Promise<FormDto> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/form` + "?ts=" + new Date().getTime()
    let headers = this.headers
    headers = headers
      .filter((h) => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "application/json"))
    return XHR.sendCommand("PUT", _url, headers, _body, this.fetchImpl)
      .then((doc) => new FormDto(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns the modified healthcare elements.
   * @summary Modify a batch of healthcare elements
   * @param body
   */
  modifyTmpForms(body?: Array<FormDto>): Promise<Array<FormDto>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/form/batch` + "?ts=" + new Date().getTime()
    let headers = this.headers
    headers = headers
      .filter((h) => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "application/json"))
    return XHR.sendCommand("PUT", _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new FormDto(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns the modified healthElement.
   * @summary Modify a healthElement
   * @param body
   */
  modifyTmpHealthElement(body?: HealthElementDto): Promise<HealthElementDto> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/healthElement` + "?ts=" + new Date().getTime()
    let headers = this.headers
    headers = headers
      .filter((h) => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "application/json"))
    return XHR.sendCommand("PUT", _url, headers, _body, this.fetchImpl)
      .then((doc) => new HealthElementDto(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns the modified healthcare elements.
   * @summary Modify a batch of healthcare elements
   * @param body
   */
  modifyTmpHealthElements(body?: Array<HealthElementDto>): Promise<Array<HealthElementDto>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/healthElement/batch` + "?ts=" + new Date().getTime()
    let headers = this.headers
    headers = headers
      .filter((h) => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "application/json"))
    return XHR.sendCommand("PUT", _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new HealthElementDto(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns the modified invoice.
   * @summary Modify a invoice
   * @param body
   */
  modifyTmpInvoice(body?: InvoiceDto): Promise<InvoiceDto> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/invoice` + "?ts=" + new Date().getTime()
    let headers = this.headers
    headers = headers
      .filter((h) => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "application/json"))
    return XHR.sendCommand("PUT", _url, headers, _body, this.fetchImpl)
      .then((doc) => new InvoiceDto(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns the modified healthcare elements.
   * @summary Modify a batch of healthcare elements
   * @param body
   */
  modifyTmpInvoices(body?: Array<InvoiceDto>): Promise<Array<InvoiceDto>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/invoice/batch` + "?ts=" + new Date().getTime()
    let headers = this.headers
    headers = headers
      .filter((h) => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "application/json"))
    return XHR.sendCommand("PUT", _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new InvoiceDto(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns the modified message.
   * @summary Modify a message
   * @param body
   */
  modifyTmpMessage(body?: MessageDto): Promise<MessageDto> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/message` + "?ts=" + new Date().getTime()
    let headers = this.headers
    headers = headers
      .filter((h) => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "application/json"))
    return XHR.sendCommand("PUT", _url, headers, _body, this.fetchImpl)
      .then((doc) => new MessageDto(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns the modified healthcare elements.
   * @summary Modify a batch of healthcare elements
   * @param body
   */
  modifyTmpMessages(body?: Array<MessageDto>): Promise<Array<MessageDto>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/message/batch` + "?ts=" + new Date().getTime()
    let headers = this.headers
    headers = headers
      .filter((h) => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "application/json"))
    return XHR.sendCommand("PUT", _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new MessageDto(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns the modified patient.
   * @summary Modify a patient
   * @param body
   */
  modifyTmpPatient(body?: PatientDto): Promise<PatientDto> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/patient` + "?ts=" + new Date().getTime()
    let headers = this.headers
    headers = headers
      .filter((h) => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "application/json"))
    return XHR.sendCommand("PUT", _url, headers, _body, this.fetchImpl)
      .then((doc) => new PatientDto(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }

  /**
   * Returns the modified healthcare elements.
   * @summary Modify a batch of healthcare elements
   * @param body
   */
  modifyTmpPatients(body?: Array<PatientDto>): Promise<Array<PatientDto>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/patient/batch` + "?ts=" + new Date().getTime()
    let headers = this.headers
    headers = headers
      .filter((h) => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "application/json"))
    return XHR.sendCommand("PUT", _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new PatientDto(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   * Response is a set containing the ID's of deleted items.
   * @summary Hard delete items.
   * @param body
   */
  purgeTmpItems(body?: Array<string>): Promise<Array<DocIdentifier>> {
    let _body = null
    _body = body

    const _url = this.host + `/tmp/batch/purge` + "?ts=" + new Date().getTime()
    let headers = this.headers
    headers = headers
      .filter((h) => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "application/json"))
    return XHR.sendCommand("POST", _url, headers, _body, this.fetchImpl)
      .then((doc) => (doc.body as Array<JSON>).map((it) => new DocIdentifier(it)))
      .catch((err) => this.handleError(err))
  }

  /**
   *
   * @param body
   * @param from
   */
  replicateToTmpDatabase(from: string, body?: Array<string>): Promise<Unit> {
    let _body = null
    _body = body

    const _url =
      this.host +
      `/tmp/replicate/from/${encodeURIComponent(String(from))}` +
      "?ts=" +
      new Date().getTime()
    let headers = this.headers
    headers = headers
      .filter((h) => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "application/json"))
    return XHR.sendCommand("POST", _url, headers, _body, this.fetchImpl)
      .then((doc) => new Unit(doc.body as JSON))
      .catch((err) => this.handleError(err))
  }
}
